// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dns

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Creates and manages Scaleway Domain record.\
// For more information, see [the documentation](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/).
//
// ## Example Usage
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/dns"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dns.NewRecord(ctx, "www", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.4"),
//				DnsZone: pulumi.String("domain.tld"),
//				Ttl:     pulumi.Int(3600),
//				Type:    pulumi.String("A"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "www2", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.5"),
//				DnsZone: pulumi.String("domain.tld"),
//				Ttl:     pulumi.Int(3600),
//				Type:    pulumi.String("A"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "mx", &dns.RecordArgs{
//				Data:     pulumi.String("mx.online.net."),
//				DnsZone:  pulumi.String("domain.tld"),
//				Priority: pulumi.Int(10),
//				Ttl:      pulumi.Int(3600),
//				Type:     pulumi.String("MX"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "mx2", &dns.RecordArgs{
//				Data:     pulumi.String("mx-cache.online.net."),
//				DnsZone:  pulumi.String("domain.tld"),
//				Priority: pulumi.Int(20),
//				Ttl:      pulumi.Int(3600),
//				Type:     pulumi.String("MX"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### With dynamic records
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/dns"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dns.NewRecord(ctx, "geoIp", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.4"),
//				DnsZone: pulumi.String("domain.tld"),
//				GeoIp: &dns.RecordGeoIpArgs{
//					Matches: dns.RecordGeoIpMatchArray{
//						&dns.RecordGeoIpMatchArgs{
//							Continents: pulumi.StringArray{
//								pulumi.String("EU"),
//							},
//							Countries: pulumi.StringArray{
//								pulumi.String("FR"),
//							},
//							Data: pulumi.String("1.2.3.5"),
//						},
//						&dns.RecordGeoIpMatchArgs{
//							Continents: pulumi.StringArray{
//								pulumi.String("NA"),
//							},
//							Data: pulumi.String("4.3.2.1"),
//						},
//					},
//				},
//				Ttl:  pulumi.Int(3600),
//				Type: pulumi.String("A"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "httpService", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.4"),
//				DnsZone: pulumi.String("domain.tld"),
//				HttpService: &dns.RecordHttpServiceArgs{
//					Ips: pulumi.StringArray{
//						pulumi.String("1.2.3.5"),
//						pulumi.String("1.2.3.6"),
//					},
//					MustContain: pulumi.String("up"),
//					Strategy:    pulumi.String("hashed"),
//					Url:         pulumi.String("http://mywebsite.com/health"),
//					UserAgent:   pulumi.String("scw_service_up"),
//				},
//				Ttl:  pulumi.Int(3600),
//				Type: pulumi.String("A"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "view", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.4"),
//				DnsZone: pulumi.String("domain.tld"),
//				Ttl:     pulumi.Int(3600),
//				Type:    pulumi.String("A"),
//				Views: dns.RecordViewArray{
//					&dns.RecordViewArgs{
//						Data:   pulumi.String("1.2.3.5"),
//						Subnet: pulumi.String("100.0.0.0/16"),
//					},
//					&dns.RecordViewArgs{
//						Data:   pulumi.String("1.2.3.6"),
//						Subnet: pulumi.String("100.1.0.0/16"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "weighted", &dns.RecordArgs{
//				Data:    pulumi.String("1.2.3.4"),
//				DnsZone: pulumi.String("domain.tld"),
//				Ttl:     pulumi.Int(3600),
//				Type:    pulumi.String("A"),
//				Weighteds: dns.RecordWeightedArray{
//					&dns.RecordWeightedArgs{
//						Ip:     pulumi.String("1.2.3.5"),
//						Weight: pulumi.Int(1),
//					},
//					&dns.RecordWeightedArgs{
//						Ip:     pulumi.String("1.2.3.6"),
//						Weight: pulumi.Int(2),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Create an instance and add records with the new instance IP
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/dns"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/instance"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			projectId := cfg.Require("projectId")
//			dnsZone := cfg.Require("dnsZone")
//			publicIp, err := instance.NewIP(ctx, "publicIp", &instance.IPArgs{
//				ProjectId: pulumi.String(projectId),
//			})
//			if err != nil {
//				return err
//			}
//			web, err := instance.NewServer(ctx, "web", &instance.ServerArgs{
//				ProjectId: pulumi.String(projectId),
//				Type:      pulumi.String("DEV1-S"),
//				Image:     pulumi.String("ubuntu_jammy"),
//				Tags: pulumi.StringArray{
//					pulumi.String("front"),
//					pulumi.String("web"),
//				},
//				IpId: publicIp.ID(),
//				RootVolume: &instance.ServerRootVolumeArgs{
//					SizeInGb: pulumi.Int(20),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "webA", &dns.RecordArgs{
//				DnsZone: pulumi.String(dnsZone),
//				Type:    pulumi.String("A"),
//				Data:    web.PublicIp,
//				Ttl:     pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "webCname", &dns.RecordArgs{
//				DnsZone: pulumi.String(dnsZone),
//				Type:    pulumi.String("CNAME"),
//				Data:    pulumi.String(fmt.Sprintf("web.%v.", dnsZone)),
//				Ttl:     pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = dns.NewRecord(ctx, "webAlias", &dns.RecordArgs{
//				DnsZone: pulumi.String(dnsZone),
//				Type:    pulumi.String("ALIAS"),
//				Data:    pulumi.String(fmt.Sprintf("web.%v.", dnsZone)),
//				Ttl:     pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ## Multiple records
//
// Some record types can have multiple `data` with the same `name` (eg: `A`, `AAAA`, `MX`, `NS`...).\
// You can duplicate a resource `dns.Record` with the same `name`, the records will be added.
//
// Please note, some record (eg: `CNAME`, Multiple dynamic records of different types...) has to be unique.
//
// ## Import
//
// Record can be imported using the `{dns_zone}/{id}`, e.g. bash
//
// ```sh
//
//	$ pulumi import scaleway:dns/record:Record www subdomain.domain.tld/11111111-1111-1111-1111-111111111111
//
// ```
type Record struct {
	pulumi.CustomResourceState

	// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
	Data pulumi.StringOutput `pulumi:"data"`
	// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
	DnsZone pulumi.StringOutput `pulumi:"dnsZone"`
	// The FQDN of the record.
	Fqdn pulumi.StringOutput `pulumi:"fqdn"`
	// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
	GeoIp RecordGeoIpPtrOutput `pulumi:"geoIp"`
	// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
	HttpService RecordHttpServicePtrOutput `pulumi:"httpService"`
	// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
	KeepEmptyZone pulumi.BoolPtrOutput `pulumi:"keepEmptyZone"`
	// The name of the record (can be an empty string for a root record).
	Name pulumi.StringOutput `pulumi:"name"`
	// The priority of the record (mostly used with an `MX` record)
	Priority pulumi.IntOutput `pulumi:"priority"`
	// The project_id you want to attach the resource to
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Does the DNS zone is the root zone or not
	RootZone pulumi.BoolOutput `pulumi:"rootZone"`
	// Time To Live of the record in seconds.
	Ttl pulumi.IntPtrOutput `pulumi:"ttl"`
	// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
	Type pulumi.StringOutput `pulumi:"type"`
	// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
	Views RecordViewArrayOutput `pulumi:"views"`
	// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
	Weighteds RecordWeightedArrayOutput `pulumi:"weighteds"`
}

// NewRecord registers a new resource with the given unique name, arguments, and options.
func NewRecord(ctx *pulumi.Context,
	name string, args *RecordArgs, opts ...pulumi.ResourceOption) (*Record, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Data == nil {
		return nil, errors.New("invalid value for required argument 'Data'")
	}
	if args.DnsZone == nil {
		return nil, errors.New("invalid value for required argument 'DnsZone'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Record
	err := ctx.RegisterResource("scaleway:dns/record:Record", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRecord gets an existing Record resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRecord(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RecordState, opts ...pulumi.ResourceOption) (*Record, error) {
	var resource Record
	err := ctx.ReadResource("scaleway:dns/record:Record", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Record resources.
type recordState struct {
	// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
	Data *string `pulumi:"data"`
	// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
	DnsZone *string `pulumi:"dnsZone"`
	// The FQDN of the record.
	Fqdn *string `pulumi:"fqdn"`
	// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
	GeoIp *RecordGeoIp `pulumi:"geoIp"`
	// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
	HttpService *RecordHttpService `pulumi:"httpService"`
	// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
	KeepEmptyZone *bool `pulumi:"keepEmptyZone"`
	// The name of the record (can be an empty string for a root record).
	Name *string `pulumi:"name"`
	// The priority of the record (mostly used with an `MX` record)
	Priority *int `pulumi:"priority"`
	// The project_id you want to attach the resource to
	ProjectId *string `pulumi:"projectId"`
	// Does the DNS zone is the root zone or not
	RootZone *bool `pulumi:"rootZone"`
	// Time To Live of the record in seconds.
	Ttl *int `pulumi:"ttl"`
	// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
	Type *string `pulumi:"type"`
	// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
	Views []RecordView `pulumi:"views"`
	// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
	Weighteds []RecordWeighted `pulumi:"weighteds"`
}

type RecordState struct {
	// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
	Data pulumi.StringPtrInput
	// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
	DnsZone pulumi.StringPtrInput
	// The FQDN of the record.
	Fqdn pulumi.StringPtrInput
	// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
	GeoIp RecordGeoIpPtrInput
	// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
	HttpService RecordHttpServicePtrInput
	// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
	KeepEmptyZone pulumi.BoolPtrInput
	// The name of the record (can be an empty string for a root record).
	Name pulumi.StringPtrInput
	// The priority of the record (mostly used with an `MX` record)
	Priority pulumi.IntPtrInput
	// The project_id you want to attach the resource to
	ProjectId pulumi.StringPtrInput
	// Does the DNS zone is the root zone or not
	RootZone pulumi.BoolPtrInput
	// Time To Live of the record in seconds.
	Ttl pulumi.IntPtrInput
	// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
	Type pulumi.StringPtrInput
	// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
	Views RecordViewArrayInput
	// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
	Weighteds RecordWeightedArrayInput
}

func (RecordState) ElementType() reflect.Type {
	return reflect.TypeOf((*recordState)(nil)).Elem()
}

type recordArgs struct {
	// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
	Data string `pulumi:"data"`
	// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
	DnsZone string `pulumi:"dnsZone"`
	// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
	GeoIp *RecordGeoIp `pulumi:"geoIp"`
	// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
	HttpService *RecordHttpService `pulumi:"httpService"`
	// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
	KeepEmptyZone *bool `pulumi:"keepEmptyZone"`
	// The name of the record (can be an empty string for a root record).
	Name *string `pulumi:"name"`
	// The priority of the record (mostly used with an `MX` record)
	Priority *int `pulumi:"priority"`
	// The project_id you want to attach the resource to
	ProjectId *string `pulumi:"projectId"`
	// Time To Live of the record in seconds.
	Ttl *int `pulumi:"ttl"`
	// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
	Type string `pulumi:"type"`
	// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
	Views []RecordView `pulumi:"views"`
	// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
	Weighteds []RecordWeighted `pulumi:"weighteds"`
}

// The set of arguments for constructing a Record resource.
type RecordArgs struct {
	// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
	Data pulumi.StringInput
	// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
	DnsZone pulumi.StringInput
	// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
	GeoIp RecordGeoIpPtrInput
	// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
	HttpService RecordHttpServicePtrInput
	// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
	KeepEmptyZone pulumi.BoolPtrInput
	// The name of the record (can be an empty string for a root record).
	Name pulumi.StringPtrInput
	// The priority of the record (mostly used with an `MX` record)
	Priority pulumi.IntPtrInput
	// The project_id you want to attach the resource to
	ProjectId pulumi.StringPtrInput
	// Time To Live of the record in seconds.
	Ttl pulumi.IntPtrInput
	// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
	Type pulumi.StringInput
	// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
	Views RecordViewArrayInput
	// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
	Weighteds RecordWeightedArrayInput
}

func (RecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*recordArgs)(nil)).Elem()
}

type RecordInput interface {
	pulumi.Input

	ToRecordOutput() RecordOutput
	ToRecordOutputWithContext(ctx context.Context) RecordOutput
}

func (*Record) ElementType() reflect.Type {
	return reflect.TypeOf((**Record)(nil)).Elem()
}

func (i *Record) ToRecordOutput() RecordOutput {
	return i.ToRecordOutputWithContext(context.Background())
}

func (i *Record) ToRecordOutputWithContext(ctx context.Context) RecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordOutput)
}

// RecordArrayInput is an input type that accepts RecordArray and RecordArrayOutput values.
// You can construct a concrete instance of `RecordArrayInput` via:
//
//	RecordArray{ RecordArgs{...} }
type RecordArrayInput interface {
	pulumi.Input

	ToRecordArrayOutput() RecordArrayOutput
	ToRecordArrayOutputWithContext(context.Context) RecordArrayOutput
}

type RecordArray []RecordInput

func (RecordArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Record)(nil)).Elem()
}

func (i RecordArray) ToRecordArrayOutput() RecordArrayOutput {
	return i.ToRecordArrayOutputWithContext(context.Background())
}

func (i RecordArray) ToRecordArrayOutputWithContext(ctx context.Context) RecordArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordArrayOutput)
}

// RecordMapInput is an input type that accepts RecordMap and RecordMapOutput values.
// You can construct a concrete instance of `RecordMapInput` via:
//
//	RecordMap{ "key": RecordArgs{...} }
type RecordMapInput interface {
	pulumi.Input

	ToRecordMapOutput() RecordMapOutput
	ToRecordMapOutputWithContext(context.Context) RecordMapOutput
}

type RecordMap map[string]RecordInput

func (RecordMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Record)(nil)).Elem()
}

func (i RecordMap) ToRecordMapOutput() RecordMapOutput {
	return i.ToRecordMapOutputWithContext(context.Background())
}

func (i RecordMap) ToRecordMapOutputWithContext(ctx context.Context) RecordMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordMapOutput)
}

type RecordOutput struct{ *pulumi.OutputState }

func (RecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Record)(nil)).Elem()
}

func (o RecordOutput) ToRecordOutput() RecordOutput {
	return o
}

func (o RecordOutput) ToRecordOutputWithContext(ctx context.Context) RecordOutput {
	return o
}

// The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
func (o RecordOutput) Data() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.Data }).(pulumi.StringOutput)
}

// The DNS Zone of the domain. If the DNS zone doesn't exist, it will be automatically created.
func (o RecordOutput) DnsZone() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.DnsZone }).(pulumi.StringOutput)
}

// The FQDN of the record.
func (o RecordOutput) Fqdn() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.Fqdn }).(pulumi.StringOutput)
}

// The Geo IP feature provides DNS resolution, based on the user’s geographical location. You can define a default IP that resolves if no Geo IP rule matches, and specify IPs for each geographical zone. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#geo-ip-records)
func (o RecordOutput) GeoIp() RecordGeoIpPtrOutput {
	return o.ApplyT(func(v *Record) RecordGeoIpPtrOutput { return v.GeoIp }).(RecordGeoIpPtrOutput)
}

// The DNS service checks the provided URL on the configured IPs and resolves the request to one of the IPs by excluding the ones not responding to the given string to check. [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#healthcheck-records)
func (o RecordOutput) HttpService() RecordHttpServicePtrOutput {
	return o.ApplyT(func(v *Record) RecordHttpServicePtrOutput { return v.HttpService }).(RecordHttpServicePtrOutput)
}

// When destroying a resource, if only NS records remain and this is set to `false`, the zone will be deleted. Please note, each zone not deleted will [cost you money](https://www.scaleway.com/en/dns/)
func (o RecordOutput) KeepEmptyZone() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Record) pulumi.BoolPtrOutput { return v.KeepEmptyZone }).(pulumi.BoolPtrOutput)
}

// The name of the record (can be an empty string for a root record).
func (o RecordOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The priority of the record (mostly used with an `MX` record)
func (o RecordOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v *Record) pulumi.IntOutput { return v.Priority }).(pulumi.IntOutput)
}

// The project_id you want to attach the resource to
func (o RecordOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Does the DNS zone is the root zone or not
func (o RecordOutput) RootZone() pulumi.BoolOutput {
	return o.ApplyT(func(v *Record) pulumi.BoolOutput { return v.RootZone }).(pulumi.BoolOutput)
}

// Time To Live of the record in seconds.
func (o RecordOutput) Ttl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Record) pulumi.IntPtrOutput { return v.Ttl }).(pulumi.IntPtrOutput)
}

// The type of the record (`A`, `AAAA`, `MX`, `CNAME`, `DNAME`, `ALIAS`, `NS`, `PTR`, `SRV`, `TXT`, `TLSA`, or `CAA`).
func (o RecordOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Record) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The answer to a DNS request is based on the client’s (resolver) subnet. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#views-records)
func (o RecordOutput) Views() RecordViewArrayOutput {
	return o.ApplyT(func(v *Record) RecordViewArrayOutput { return v.Views }).(RecordViewArrayOutput)
}

// You provide a list of IPs with their corresponding weights. These weights are used to proportionally direct requests to each IP. Depending on the weight of a record more or fewer requests are answered with its related IP compared to the others in the list. *(Can be more than 1)* [Documentation and usage example](https://www.scaleway.com/en/docs/network/domains-and-dns/how-to/manage-dns-records/#weight-records)
func (o RecordOutput) Weighteds() RecordWeightedArrayOutput {
	return o.ApplyT(func(v *Record) RecordWeightedArrayOutput { return v.Weighteds }).(RecordWeightedArrayOutput)
}

type RecordArrayOutput struct{ *pulumi.OutputState }

func (RecordArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Record)(nil)).Elem()
}

func (o RecordArrayOutput) ToRecordArrayOutput() RecordArrayOutput {
	return o
}

func (o RecordArrayOutput) ToRecordArrayOutputWithContext(ctx context.Context) RecordArrayOutput {
	return o
}

func (o RecordArrayOutput) Index(i pulumi.IntInput) RecordOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Record {
		return vs[0].([]*Record)[vs[1].(int)]
	}).(RecordOutput)
}

type RecordMapOutput struct{ *pulumi.OutputState }

func (RecordMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Record)(nil)).Elem()
}

func (o RecordMapOutput) ToRecordMapOutput() RecordMapOutput {
	return o
}

func (o RecordMapOutput) ToRecordMapOutputWithContext(ctx context.Context) RecordMapOutput {
	return o
}

func (o RecordMapOutput) MapIndex(k pulumi.StringInput) RecordOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Record {
		return vs[0].(map[string]*Record)[vs[1].(string)]
	}).(RecordOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RecordInput)(nil)).Elem(), &Record{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordArrayInput)(nil)).Elem(), RecordArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordMapInput)(nil)).Elem(), RecordMap{})
	pulumi.RegisterOutputType(RecordOutput{})
	pulumi.RegisterOutputType(RecordArrayOutput{})
	pulumi.RegisterOutputType(RecordMapOutput{})
}
