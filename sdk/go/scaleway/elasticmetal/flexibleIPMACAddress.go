// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package elasticmetal

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/internal"
)

// Creates and manages Scaleway Flexible IP Mac Addresses.
// For more information, see [the documentation](https://developers.scaleway.com/en/products/flexible-ip/api).
//
// ## Example Usage
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/elasticmetal"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			mainFlexibleIP, err := elasticmetal.NewFlexibleIP(ctx, "mainFlexibleIP", nil)
//			if err != nil {
//				return err
//			}
//			_, err = elasticmetal.NewFlexibleIPMACAddress(ctx, "mainFlexibleIPMACAddress", &elasticmetal.FlexibleIPMACAddressArgs{
//				FlexibleIpId: mainFlexibleIP.ID(),
//				Type:         pulumi.String("kvm"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Duplicate on many other flexible IPs
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/raeumlich/pulumi-scaleway/sdk/go/scaleway/elasticmetal"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myOffer, err := elasticmetal.GetBareMetalOffer(ctx, &elasticmetal.GetBareMetalOfferArgs{
//				Name: pulumi.StringRef("EM-B112X-SSD"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			base, err := elasticmetal.NewBareMetalServer(ctx, "base", &elasticmetal.BareMetalServerArgs{
//				Offer:                  *pulumi.String(myOffer.OfferId),
//				InstallConfigAfterward: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			ip01, err := elasticmetal.NewFlexibleIP(ctx, "ip01", &elasticmetal.FlexibleIPArgs{
//				ServerId: base.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			ip02, err := elasticmetal.NewFlexibleIP(ctx, "ip02", &elasticmetal.FlexibleIPArgs{
//				ServerId: base.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			ip03, err := elasticmetal.NewFlexibleIP(ctx, "ip03", &elasticmetal.FlexibleIPArgs{
//				ServerId: base.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = elasticmetal.NewFlexibleIPMACAddress(ctx, "main", &elasticmetal.FlexibleIPMACAddressArgs{
//				FlexibleIpId: ip01.ID(),
//				Type:         pulumi.String("kvm"),
//				FlexibleIpIdsToDuplicates: pulumi.StringArray{
//					ip02.ID(),
//					ip03.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Flexible IP Mac Addresses can be imported using the `{zone}/{id}`, e.g. bash
//
// ```sh
//
//	$ pulumi import scaleway:elasticmetal/flexibleIPMACAddress:FlexibleIPMACAddress main fr-par-1/11111111-1111-1111-1111-111111111111
//
// ```
type FlexibleIPMACAddress struct {
	pulumi.CustomResourceState

	// The Virtual MAC address.
	Address pulumi.StringOutput `pulumi:"address"`
	// The date at which the Virtual Mac Address was created (RFC 3339 format).
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The ID of the flexible IP for which to generate a virtual MAC.
	FlexibleIpId pulumi.StringOutput `pulumi:"flexibleIpId"`
	// The IDs of the flexible IPs on which to duplicate the virtual MAC.
	// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
	FlexibleIpIdsToDuplicates pulumi.StringArrayOutput `pulumi:"flexibleIpIdsToDuplicates"`
	// The Virtual MAC status.
	Status pulumi.StringOutput `pulumi:"status"`
	// The type of the virtual MAC.
	Type pulumi.StringOutput `pulumi:"type"`
	// The date at which the Virtual Mac Address was last updated (RFC 3339 format).
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// The zone of the Virtual Mac Address.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewFlexibleIPMACAddress registers a new resource with the given unique name, arguments, and options.
func NewFlexibleIPMACAddress(ctx *pulumi.Context,
	name string, args *FlexibleIPMACAddressArgs, opts ...pulumi.ResourceOption) (*FlexibleIPMACAddress, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FlexibleIpId == nil {
		return nil, errors.New("invalid value for required argument 'FlexibleIpId'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FlexibleIPMACAddress
	err := ctx.RegisterResource("scaleway:elasticmetal/flexibleIPMACAddress:FlexibleIPMACAddress", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFlexibleIPMACAddress gets an existing FlexibleIPMACAddress resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFlexibleIPMACAddress(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FlexibleIPMACAddressState, opts ...pulumi.ResourceOption) (*FlexibleIPMACAddress, error) {
	var resource FlexibleIPMACAddress
	err := ctx.ReadResource("scaleway:elasticmetal/flexibleIPMACAddress:FlexibleIPMACAddress", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FlexibleIPMACAddress resources.
type flexibleIPMACAddressState struct {
	// The Virtual MAC address.
	Address *string `pulumi:"address"`
	// The date at which the Virtual Mac Address was created (RFC 3339 format).
	CreatedAt *string `pulumi:"createdAt"`
	// The ID of the flexible IP for which to generate a virtual MAC.
	FlexibleIpId *string `pulumi:"flexibleIpId"`
	// The IDs of the flexible IPs on which to duplicate the virtual MAC.
	// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
	FlexibleIpIdsToDuplicates []string `pulumi:"flexibleIpIdsToDuplicates"`
	// The Virtual MAC status.
	Status *string `pulumi:"status"`
	// The type of the virtual MAC.
	Type *string `pulumi:"type"`
	// The date at which the Virtual Mac Address was last updated (RFC 3339 format).
	UpdatedAt *string `pulumi:"updatedAt"`
	// The zone of the Virtual Mac Address.
	Zone *string `pulumi:"zone"`
}

type FlexibleIPMACAddressState struct {
	// The Virtual MAC address.
	Address pulumi.StringPtrInput
	// The date at which the Virtual Mac Address was created (RFC 3339 format).
	CreatedAt pulumi.StringPtrInput
	// The ID of the flexible IP for which to generate a virtual MAC.
	FlexibleIpId pulumi.StringPtrInput
	// The IDs of the flexible IPs on which to duplicate the virtual MAC.
	// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
	FlexibleIpIdsToDuplicates pulumi.StringArrayInput
	// The Virtual MAC status.
	Status pulumi.StringPtrInput
	// The type of the virtual MAC.
	Type pulumi.StringPtrInput
	// The date at which the Virtual Mac Address was last updated (RFC 3339 format).
	UpdatedAt pulumi.StringPtrInput
	// The zone of the Virtual Mac Address.
	Zone pulumi.StringPtrInput
}

func (FlexibleIPMACAddressState) ElementType() reflect.Type {
	return reflect.TypeOf((*flexibleIPMACAddressState)(nil)).Elem()
}

type flexibleIPMACAddressArgs struct {
	// The ID of the flexible IP for which to generate a virtual MAC.
	FlexibleIpId string `pulumi:"flexibleIpId"`
	// The IDs of the flexible IPs on which to duplicate the virtual MAC.
	// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
	FlexibleIpIdsToDuplicates []string `pulumi:"flexibleIpIdsToDuplicates"`
	// The type of the virtual MAC.
	Type string `pulumi:"type"`
	// The zone of the Virtual Mac Address.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a FlexibleIPMACAddress resource.
type FlexibleIPMACAddressArgs struct {
	// The ID of the flexible IP for which to generate a virtual MAC.
	FlexibleIpId pulumi.StringInput
	// The IDs of the flexible IPs on which to duplicate the virtual MAC.
	// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
	FlexibleIpIdsToDuplicates pulumi.StringArrayInput
	// The type of the virtual MAC.
	Type pulumi.StringInput
	// The zone of the Virtual Mac Address.
	Zone pulumi.StringPtrInput
}

func (FlexibleIPMACAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*flexibleIPMACAddressArgs)(nil)).Elem()
}

type FlexibleIPMACAddressInput interface {
	pulumi.Input

	ToFlexibleIPMACAddressOutput() FlexibleIPMACAddressOutput
	ToFlexibleIPMACAddressOutputWithContext(ctx context.Context) FlexibleIPMACAddressOutput
}

func (*FlexibleIPMACAddress) ElementType() reflect.Type {
	return reflect.TypeOf((**FlexibleIPMACAddress)(nil)).Elem()
}

func (i *FlexibleIPMACAddress) ToFlexibleIPMACAddressOutput() FlexibleIPMACAddressOutput {
	return i.ToFlexibleIPMACAddressOutputWithContext(context.Background())
}

func (i *FlexibleIPMACAddress) ToFlexibleIPMACAddressOutputWithContext(ctx context.Context) FlexibleIPMACAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlexibleIPMACAddressOutput)
}

// FlexibleIPMACAddressArrayInput is an input type that accepts FlexibleIPMACAddressArray and FlexibleIPMACAddressArrayOutput values.
// You can construct a concrete instance of `FlexibleIPMACAddressArrayInput` via:
//
//	FlexibleIPMACAddressArray{ FlexibleIPMACAddressArgs{...} }
type FlexibleIPMACAddressArrayInput interface {
	pulumi.Input

	ToFlexibleIPMACAddressArrayOutput() FlexibleIPMACAddressArrayOutput
	ToFlexibleIPMACAddressArrayOutputWithContext(context.Context) FlexibleIPMACAddressArrayOutput
}

type FlexibleIPMACAddressArray []FlexibleIPMACAddressInput

func (FlexibleIPMACAddressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FlexibleIPMACAddress)(nil)).Elem()
}

func (i FlexibleIPMACAddressArray) ToFlexibleIPMACAddressArrayOutput() FlexibleIPMACAddressArrayOutput {
	return i.ToFlexibleIPMACAddressArrayOutputWithContext(context.Background())
}

func (i FlexibleIPMACAddressArray) ToFlexibleIPMACAddressArrayOutputWithContext(ctx context.Context) FlexibleIPMACAddressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlexibleIPMACAddressArrayOutput)
}

// FlexibleIPMACAddressMapInput is an input type that accepts FlexibleIPMACAddressMap and FlexibleIPMACAddressMapOutput values.
// You can construct a concrete instance of `FlexibleIPMACAddressMapInput` via:
//
//	FlexibleIPMACAddressMap{ "key": FlexibleIPMACAddressArgs{...} }
type FlexibleIPMACAddressMapInput interface {
	pulumi.Input

	ToFlexibleIPMACAddressMapOutput() FlexibleIPMACAddressMapOutput
	ToFlexibleIPMACAddressMapOutputWithContext(context.Context) FlexibleIPMACAddressMapOutput
}

type FlexibleIPMACAddressMap map[string]FlexibleIPMACAddressInput

func (FlexibleIPMACAddressMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FlexibleIPMACAddress)(nil)).Elem()
}

func (i FlexibleIPMACAddressMap) ToFlexibleIPMACAddressMapOutput() FlexibleIPMACAddressMapOutput {
	return i.ToFlexibleIPMACAddressMapOutputWithContext(context.Background())
}

func (i FlexibleIPMACAddressMap) ToFlexibleIPMACAddressMapOutputWithContext(ctx context.Context) FlexibleIPMACAddressMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FlexibleIPMACAddressMapOutput)
}

type FlexibleIPMACAddressOutput struct{ *pulumi.OutputState }

func (FlexibleIPMACAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FlexibleIPMACAddress)(nil)).Elem()
}

func (o FlexibleIPMACAddressOutput) ToFlexibleIPMACAddressOutput() FlexibleIPMACAddressOutput {
	return o
}

func (o FlexibleIPMACAddressOutput) ToFlexibleIPMACAddressOutputWithContext(ctx context.Context) FlexibleIPMACAddressOutput {
	return o
}

// The Virtual MAC address.
func (o FlexibleIPMACAddressOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.Address }).(pulumi.StringOutput)
}

// The date at which the Virtual Mac Address was created (RFC 3339 format).
func (o FlexibleIPMACAddressOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The ID of the flexible IP for which to generate a virtual MAC.
func (o FlexibleIPMACAddressOutput) FlexibleIpId() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.FlexibleIpId }).(pulumi.StringOutput)
}

// The IDs of the flexible IPs on which to duplicate the virtual MAC.
// > **Important:** The flexible IPs need to be attached to the same server for the operation to work.
func (o FlexibleIPMACAddressOutput) FlexibleIpIdsToDuplicates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringArrayOutput { return v.FlexibleIpIdsToDuplicates }).(pulumi.StringArrayOutput)
}

// The Virtual MAC status.
func (o FlexibleIPMACAddressOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// The type of the virtual MAC.
func (o FlexibleIPMACAddressOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The date at which the Virtual Mac Address was last updated (RFC 3339 format).
func (o FlexibleIPMACAddressOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// The zone of the Virtual Mac Address.
func (o FlexibleIPMACAddressOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *FlexibleIPMACAddress) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type FlexibleIPMACAddressArrayOutput struct{ *pulumi.OutputState }

func (FlexibleIPMACAddressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FlexibleIPMACAddress)(nil)).Elem()
}

func (o FlexibleIPMACAddressArrayOutput) ToFlexibleIPMACAddressArrayOutput() FlexibleIPMACAddressArrayOutput {
	return o
}

func (o FlexibleIPMACAddressArrayOutput) ToFlexibleIPMACAddressArrayOutputWithContext(ctx context.Context) FlexibleIPMACAddressArrayOutput {
	return o
}

func (o FlexibleIPMACAddressArrayOutput) Index(i pulumi.IntInput) FlexibleIPMACAddressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FlexibleIPMACAddress {
		return vs[0].([]*FlexibleIPMACAddress)[vs[1].(int)]
	}).(FlexibleIPMACAddressOutput)
}

type FlexibleIPMACAddressMapOutput struct{ *pulumi.OutputState }

func (FlexibleIPMACAddressMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FlexibleIPMACAddress)(nil)).Elem()
}

func (o FlexibleIPMACAddressMapOutput) ToFlexibleIPMACAddressMapOutput() FlexibleIPMACAddressMapOutput {
	return o
}

func (o FlexibleIPMACAddressMapOutput) ToFlexibleIPMACAddressMapOutputWithContext(ctx context.Context) FlexibleIPMACAddressMapOutput {
	return o
}

func (o FlexibleIPMACAddressMapOutput) MapIndex(k pulumi.StringInput) FlexibleIPMACAddressOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FlexibleIPMACAddress {
		return vs[0].(map[string]*FlexibleIPMACAddress)[vs[1].(string)]
	}).(FlexibleIPMACAddressOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FlexibleIPMACAddressInput)(nil)).Elem(), &FlexibleIPMACAddress{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlexibleIPMACAddressArrayInput)(nil)).Elem(), FlexibleIPMACAddressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FlexibleIPMACAddressMapInput)(nil)).Elem(), FlexibleIPMACAddressMap{})
	pulumi.RegisterOutputType(FlexibleIPMACAddressOutput{})
	pulumi.RegisterOutputType(FlexibleIPMACAddressArrayOutput{})
	pulumi.RegisterOutputType(FlexibleIPMACAddressMapOutput{})
}
