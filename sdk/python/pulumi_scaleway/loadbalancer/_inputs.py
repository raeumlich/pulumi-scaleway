# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ACLActionArgs',
    'ACLActionRedirectArgs',
    'ACLMatchArgs',
    'BackendHealthCheckHttpArgs',
    'BackendHealthCheckHttpsArgs',
    'BackendHealthCheckTcpArgs',
    'CertficateCustomCertificateArgs',
    'CertficateLetsencryptArgs',
    'FrontendAclArgs',
    'FrontendAclActionArgs',
    'FrontendAclActionRedirectArgs',
    'FrontendAclMatchArgs',
    'LoadBalancerPrivateNetworkArgs',
]

@pulumi.input_type
class ACLActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['ACLActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        :param pulumi.Input[Sequence[pulumi.Input['ACLActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ACLActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ACLActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


@pulumi.input_type
class ACLActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[str] target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ACLMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[str]] = None,
                 http_filter_option: Optional[pulumi.Input[str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 invert: Optional[pulumi.Input[bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[str] http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param pulumi.Input[bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter", value)

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[str]]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter_option", value)

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_subnets", value)


@pulumi.input_type
class BackendHealthCheckHttpArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 code: Optional[pulumi.Input[int]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The HTTPS endpoint URL to call for HC requests.
        :param pulumi.Input[int] code: The expected HTTP status code.
        :param pulumi.Input[str] host_header: The HTTP host header to use for HC requests.
        :param pulumi.Input[str] method: The HTTP method to use for HC requests.
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


@pulumi.input_type
class BackendHealthCheckHttpsArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 code: Optional[pulumi.Input[int]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The HTTPS endpoint URL to call for HC requests.
        :param pulumi.Input[int] code: The expected HTTP status code.
        :param pulumi.Input[str] host_header: The HTTP host header to use for HC requests.
        :param pulumi.Input[str] method: The HTTP method to use for HC requests.
        :param pulumi.Input[str] sni: The SNI to use for HC requests over SSL.
        """
        pulumi.set(__self__, "uri", uri)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)


@pulumi.input_type
class BackendHealthCheckTcpArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class CertficateCustomCertificateArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Full PEM-formatted certificate chain.
               
               > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Full PEM-formatted certificate chain.

        > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


@pulumi.input_type
class CertficateLetsencryptArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str],
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] common_name: Main domain of the certificate. A new certificate will be created if this field is changed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subject_alternative_names: Array of alternative domain names.  A new certificate will be created if this field is changed.
               
               > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        pulumi.set(__self__, "common_name", common_name)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        Main domain of the certificate. A new certificate will be created if this field is changed.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of alternative domain names.  A new certificate will be created if this field is changed.

        > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alternative_names", value)


@pulumi.input_type
class FrontendAclArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['FrontendAclActionArgs'],
                 match: pulumi.Input['FrontendAclMatchArgs'],
                 created_at: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['FrontendAclActionArgs'] action: Action to undertake when an ACL filter matches.
        :param pulumi.Input['FrontendAclMatchArgs'] match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        :param pulumi.Input[str] name: The ACL name. If not provided it will be randomly generated.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match", match)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['FrontendAclActionArgs']:
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['FrontendAclActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['FrontendAclMatchArgs']:
        """
        The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['FrontendAclMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class FrontendAclActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['FrontendAclActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        :param pulumi.Input[Sequence[pulumi.Input['FrontendAclActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        pulumi.set(__self__, "type", type)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontendAclActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontendAclActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


@pulumi.input_type
class FrontendAclActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[str] target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FrontendAclMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[str]] = None,
                 http_filter_option: Optional[pulumi.Input[str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 invert: Optional[pulumi.Input[bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[str] http_filter_option: If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param pulumi.Input[bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        if http_filter is not None:
            pulumi.set(__self__, "http_filter", http_filter)
        if http_filter_option is not None:
            pulumi.set(__self__, "http_filter_option", http_filter_option)
        if http_filter_values is not None:
            pulumi.set(__self__, "http_filter_values", http_filter_values)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter", value)

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[str]]:
        """
        If you have `http_filter` at `http_header_match`, you can use this field to filter on the HTTP header's value.
        """
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter_option", value)

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_subnets", value)


@pulumi.input_type
class LoadBalancerPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[str],
                 dhcp_config: Optional[pulumi.Input[bool]] = None,
                 static_config: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_network_id: (Required) The ID of the Private Network to associate.
        :param pulumi.Input[bool] dhcp_config: (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        :param pulumi.Input[str] static_config: (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        :param pulumi.Input[str] zone: `zone`) The zone of the load-balancer.
        """
        pulumi.set(__self__, "private_network_id", private_network_id)
        if dhcp_config is not None:
            pulumi.set(__self__, "dhcp_config", dhcp_config)
        if static_config is not None:
            pulumi.set(__self__, "static_config", static_config)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[str]:
        """
        (Required) The ID of the Private Network to associate.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_network_id", value)

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        """
        return pulumi.get(self, "dhcp_config")

    @dhcp_config.setter
    def dhcp_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp_config", value)

    @property
    @pulumi.getter(name="staticConfig")
    def static_config(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        """
        return pulumi.get(self, "static_config")

    @static_config.setter
    def static_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static_config", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        `zone`) The zone of the load-balancer.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


